<?php
/**
 +-----------------------------------------------------------------------------
 * 概率算法
 +-----------------------------------------------------------------------------
 * @param array $proArr
 * @return array
 * array('a'=>20,'b'=>30,'c'=>50) a 发生概率20，b发生概率30，c发生概率50
 +-----------------------------------------------------------------------------
 */
function get_rand($proArr =array('a'=>20,'b'=>30,'c'=>50)) { 
    $result = ''; 
    //概率数组的总概率精度 
    $proSum = array_sum($proArr); 
    //概率数组循环 
    foreach ($proArr as $key => $proCur) { 
        $randNum = mt_rand(1, $proSum);             //抽取随机数
        if ($randNum <= $proCur) { 
            $result = $key;                         //得出结果
            break; 
        } else { 
            $proSum -= $proCur;                     
        } 
    } 
    unset ($proArr); 
    return $result; 
}
/**
 +-----------------------------------------------------------------------------
 * 打印金字塔
 +-----------------------------------------------------------------------------
 * @param number $num
 * @param mixed 占位符
 * @return string $str
 +-----------------------------------------------------------------------------
 */
function print_tower($num=7, $char='&nbsp;')
{
    if ($num <= 0) return '';
    for($i=1; $i<=$num; $i++)
    {
        @$str .="<br />";
        for($j=1; $j<=$i; $j++)
        {
            if ($j == 1) 
            {
                for($k=1; $k<=$num-$i;$k++)
                {
                    $str .= $char;
                }
            }
            $str .= '*'.$char;
            //此处需一个空格占位符
            if ($char == '&nbsp;') {
            	$str .= ' ';
            }
        }
    }
    return $str;
}
/**
 +-----------------------------------------------------------------------------
 * 冒泡排序
 +-----------------------------------------------------------------------------
 * 思路分析：在要排序的一组数中，对当前还未排好的序列，
 * 从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。
 * 即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
 +-----------------------------------------------------------------------------
 */
function bubble_sort($arr=array(1,43,54,62,21,66,32,78,36,76,39))
{  
    $len = count($arr);
    //该层循环控制 需要冒泡的轮数
    for($i=1; $i<$len; $i++)
    { //该层循环用来控制每轮 冒出一个数 需要比较的次数
        for($k=0; $k<$len-$i; $k++) //最大或最小的已经排序完，下一轮循环可以减一
        {
           if($arr[$k] > $arr[$k+1])
            {
                $tmp = $arr[$k+1];
                $arr[$k+1] = $arr[$k];
                $arr[$k] = $tmp;
                @$arr['cly_times'] +=1; //设置循环结束
            }
        }
        if ($arr['cly_times'] == $arr['cly_times']-1) {
        	return $arr;
        }
    }
    return $arr;
}

/**
 +-----------------------------------------------------------------------------
 * 选择排序
 +-----------------------------------------------------------------------------
 * 思路分析：在要排序的一组数中，选出最小的一个数与第一个位置的数交换。
 * 然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和
 * 最后一个数比较为止。
 +-----------------------------------------------------------------------------
 */
function select_sort($arr=array(1,43,54,62,21,66,32,78,36,76,39)) {
	//双重循环完成，外层控制轮数，内层控制比较次数
 	$len = count($arr);
    for($i=0; $i < $len-1; $i++) { //最后一轮只有一个数可以不比较-1
        //先假设最小的值的位置
        $p = $i;
        for($j=$i+1; $j < $len; $j++) { // $i控制第几轮最小,默认第一个为假设最小+1
            //$arr[$p] 是当前已知的最小值
            if($arr[$p] > $arr[$j]) {
            	//比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。
                $p = $j;
            }
        }
        //已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。
        if($p != $i) {
            $tmp = $arr[$p];
            $arr[$p] = $arr[$i];
            $arr[$i] = $tmp;
        }
    }
    //返回最终结果
    return $arr;
}

/**
 +-----------------------------------------------------------------------------
 * 插入排序
 +-----------------------------------------------------------------------------
 * 思路分析：在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插
 * 到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。
 +-----------------------------------------------------------------------------
 */
function insert_sort($arr=array(1,43,54,62,21,66,32,78,36,76,39)) {
    $len = count($arr); 
    for($i=1; $i < $len; $i++) {
        $tmp = $arr[$i];
        //内层循环控制，比较并插入
        for($j=$i-1; $j >= 0; $j--) {
            if($tmp < $arr[$j]) {
                //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换
                $arr[$j+1] = $arr[$j];
                $arr[$j] = $tmp;
            } else {
                //如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。
                break;
            }
        }
    }
    return $arr;
}

/**
 +-----------------------------------------------------------------------------
 * 快速排序
 +-----------------------------------------------------------------------------
 * 思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描
 * 将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元
 * 素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。
 +-----------------------------------------------------------------------------
 */
function quick_sort($arr=array(1,43,54,62,21,66,32,78,36,76,39)) {
    //先判断是否需要继续进行
    $length = count($arr);
    if($length <= 1) {
        return $arr;
    }
    //选择第一个元素作为基准
    $base_num = $arr[0];
    //遍历除了标尺外的所有元素，按照大小关系放入两个数组内
    //初始化两个数组
    $left_array  = array();  //小于基准的
    $right_array = array();  //大于基准的
    for($i=1; $i<$length; $i++) {
        if($base_num > $arr[$i]) {
            //放入左边数组
            $left_array[] = $arr[$i];
        } else {
            //放入右边
            $right_array[] = $arr[$i];
        }
    }
    //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数
    $left_array  = quick_sort($left_array);
    $right_array = quick_sort($right_array);
    //合并
    return array_merge($left_array, array($base_num), $right_array);
}

/**
 +-----------------------------------------------------------------------------
 * 二分查找（数组里查找某个元素）
 +-----------------------------------------------------------------------------
 * @param $arr 查找的数组
 * @param $target 查找目标
 * @return mixed
 * 使用PHP描述顺序查找和二分查找（也叫做折半查找）算法，顺序查找必须考虑效率，
 * 对象可以是一个有序数组
 +-----------------------------------------------------------------------------
 */
function binary_earch(Array $arr, $target) {
    $low  = 0;
    $high = count($arr) - 1;
    while($low <= $high) {
        $mid = floor(($low + $high) / 2);
        //找到元素
        if($arr[$mid] == $target) return $mid;
        //中元素比目标大,查找左部
        if($arr[$mid] > $target) $high = $mid - 1;
        //重元素比目标小,查找右部
        if($arr[$mid] < $target) $low = $mid + 1;
    }
    //查找失败
    return false;
}
/**
 +-----------------------------------------------------------------------------
 * 顺序查找（数组里查找某个元素）
 +-----------------------------------------------------------------------------
 * @param array $array
 * @param number $n
 * @param string $k
 * @return mixed
 * 按顺序查找
 +-----------------------------------------------------------------------------
 */
function seq_sch($array, $n, $k){
    $array[$n] = $k;
    for($i=0; $i < $n; $i++) {
        if ($array[$i] == $k) {
            break;
        }
    }
    if ($i < $n){
        return $i;
    }else{
        return -1;
    }
}

