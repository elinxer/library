<?php
/**
 +-----------------------------------------------------------------------------
 * @ 金块问题
 +-----------------------------------------------------------------------------
 * 问题描述：老板有一袋金块（共n块，n是2的幂n>=2），最优秀的雇员得到其中最重要
 * 的一块，最差的雇员得到其中最轻的一块。假如有一台比较重量的仪器，希望用最少
 * 的比较次数找出最重合最轻的金块。
 +-----------------------------------------------------------------------------
 * 算法设计1：解决问题的简单方法是用蛮力策略，对金块逐个地进行比较查找。先拿两
 * 块比较重量，留下重的一个与下一块比较，直到全部比较完毕，就找到最重的金块。
 * 算法类似一趟选择排序。
 +-----------------------------------------------------------------------------
 * 算法分析：以上算法只需枚举尝试20 x 33 = 660 次。实现时约束条件又限定z能被3
 * 整除时，才会判断 5 * x + 3 * y + z/3 =100.这样省去了z不整除3时的算术计算和
 * 条件，进一步提高了算法的效率。此算法结果有三个解
 +-----------------------------------------------------------------------------
 */

$t = max_min_01(array(323,41,22,444,3211,1));

var_dump($t);

function max_min_01($a) {
	$max = $a[1];
	$min = $a[1];
	$n = count($a)-1;
	for ($i=2; $i <= $n; $i++) { 
		if ($max < $a[$i]) {
			$max = $a[$i];
		} else if ($min > $a[$i]) {
			$min = $a[$i];
		}
	}
	return array('max'=>$max, 'min'=>$min);
}


