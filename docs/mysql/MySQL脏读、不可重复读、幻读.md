### MySQL脏读、不可重复读、幻读

不可重复读，两次或者多次的相同查询，获取到不同的结果（这里需要注意，这里的结果，返回的记录条数是一样的，只是记录内容发生了改变）

而幻读，两次或者多次的相同查询，获取到不同的记录条数（被其他事务增加或者删除记录）


事务的特性：

原子性：指处于同一个事务中的多条语句是不可分割的。
一致性：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。比如转账，转账前两个账户余额之和为2k，转账之后也应该是2K。
隔离性：指多线程环境下，一个线程中的事务不能被其他线程中的事务打扰
持久性：事务一旦提交，就应该被永久保存起来。
事务隔离性问题： 
如果不考虑事务的隔离性，会出现以下问题：

脏读：指一个线程中的事务读取到了另外一个线程中未提交的数据。
不可重复读（虚读）：指一个线程中的事务读取到了另外一个线程中提交的update的数据。
幻读：指一个线程中的事务读取到了另外一个线程中提交的insert的数据。
隔离级别：

| 隔离级别 |  脏读（Dirty Read） | 不可重复读（NonRepeatable Read）| 幻读（Phantom Read）|
|----|----|----|----- |
| 未提交读（Read uncommitted） | 可能| 可能| 可能|
| 已提交读（Read committed） |	不可能	| 可能	|可能|
| 可重复读（Repeatable read） | 不可能	| 不可能 |	可能|
| 可串行化（Serializable ）| 不可能| 不可能|	不可能|

级别越高，数据越安全，但性能越低。

不可重复读与幻读比较相似，都是在一个事务中多次读取到不同的数据。网络上的总结如下： 
不可重复读：所谓的虚读，也就是大家经常说的不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 
一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另 一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内 两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。 
所谓幻读，是指事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。 
幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也 修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一 样.一般解决幻读的方法是增加范围锁RangeS，锁定检锁范围为只读，这样就避免了幻读。简单来说，幻读是由插入或者删除引起的。 
大致的区别在于不可重复读是由于另一个事务对数据的更改所造成的，而幻读是由于另一个事务插入或删除引起的。

不可重复读（虚读）和幻读的差别： 
从总的结果来看, 似乎两者都表现为两次读取的结果不一致. 
但如果你从控制的角度来看, 两者的区别就比较大： 
对于前者, 只需要锁住满足条件的记录 
对于后者, 要锁住满足条件及其相近的记录

转载：[MySQL脏读、不可重复读、幻读](https://blog.csdn.net/weixin_42386014/article/details/81811129)
